{
  "hash": "39ac95a041f043f976923632d27bd7e3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Yashi Analysis\"\nformat:\n  html:\n    code-fold: false        # Show code by default\n    code-copy: true         # Enable copy button for code blocks\nexecute:\n  echo: true               # Globally show code unless overridden\njupyter: python3\n---\n\n\n## 1. Data Loading & Overview\n\n\n#| label: data-loading\nimport pandas as pd\nimport numpy as np\n\ndf = pd.read_csv(\"_extra/_Audio_Files_/Yashi_s_Music/Y_audio_philes_final_features_mk1_filled_Yashi.csv\")\n\nprint(df.head())\nprint(df.info())\nprint(\"Missing values per column:\")\nprint(df.isnull().sum())\n\n#| label: preprocessing\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\n\ndf_non_feature = [\"artist\", \"country\", \"language\", \"track_type\"]\ndf_number_feature = [\n  c for c in df.select_dtypes(include=[np.number]).columns \n  if c not in df_non_feature\n]\nprint(\"Numerical features used:\", df_number_feature)\n\n# Standardize numerical features\nscaler = StandardScaler()\ndf[df_number_feature] = scaler.fit_transform(df[df_number_feature])\n\n# Encode target variable\nle = LabelEncoder()\ny_all = le.fit_transform(df[\"language\"].astype(str))\nlabel_names = le.classes_\n\n\n#| label: track-type-distribution\ntrack_type_all = {0: \"complete_song\", 1: \"vocal_only\", 2: \"no_vocal\"}\ntrack_type_specs = {\n  name: (df[\"track_type\"] == code) \n  for code, name in track_type_all.items()\n}\n\nfor name, mask in track_type_specs.items():\n  print(f\"{name}: {int(mask.sum())} samples\")\n\n#| label: model-comparison\nimport numpy as np\nfrom sklearn.model_selection import StratifiedKFold, cross_validate\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import (\n    accuracy_score, precision_score, recall_score, f1_score, make_scorer\n)\n\nk = 5\nskf = StratifiedKFold(n_splits=k, shuffle=True, random_state=42)\n\nmodels = {\n  \"LogReg\": LogisticRegression(max_iter=500, class_weight=\"balanced\", random_state=42),\n  \"RandomForest\": RandomForestClassifier(\n      n_estimators=400, class_weight=\"balanced_subsample\", random_state=42, n_jobs=-1\n  ),\n  \"SVM_linear\": SVC(kernel=\"linear\", class_weight=\"balanced\", random_state=42),\n}\n\nscoring = {\n  \"accuracy\": make_scorer(accuracy_score),\n  \"precision\": make_scorer(precision_score, average=\"macro\"),\n  \"recall\": make_scorer(recall_score, average=\"macro\"),\n  \"f1\": make_scorer(f1_score, average=\"macro\"),\n}\n\nresults = []\n\nfor code, name in track_type_all.items():\n  df_eval = df.loc[df[\"track_type\"] == code].reset_index(drop=True)\n  X = df_eval[df_number_feature]\n  y = le.transform(df_eval[\"language\"].astype(str))\n  \n  for model_name, clf in models.items():\n    cv = cross_validate(\n      clf, X, y, cv=skf, scoring=scoring, n_jobs=1, return_train_score=False\n    )\n    metrics = {metric: np.mean(cv[f\"test_{metric}\"]) for metric in scoring}\n    results.append({\n      \"track_type\": name,\n      \"model\": model_name,\n      **metrics\n    })\n    print(\n      f\"[{name} - {model_name}] \"\n      f\"Acc={metrics['accuracy']:.3f} | \"\n      f\"Prec={metrics['precision']:.3f} | \"\n      f\"Rec={metrics['recall']:.3f} | \"\n      f\"F1={metrics['f1']:.3f}\"\n    )\n\n#| label: final-model-training\nfinal_ablation = \"vocal_only\"\nfinal_model_name = \"SVM_linear\"\nprint(f\"[Final model] Ablation = {final_ablation} | Model = {final_model_name}\")\n\ndf_best = df.loc[track_type_specs[final_ablation]].reset_index(drop=True)\nX_best = df_best[df_number_feature]\ny_best = le.transform(df_best[\"language\"].astype(str))\n\nfinal_clf = SVC(kernel=\"linear\", class_weight=\"balanced\", random_state=42)\nfinal_clf.fit(X_best, y_best)\n\nprint(\n  f\"[Final Train] Done on {final_ablation} - {final_model_name} | \"\n  f\"n_samples = {len(df_best)}\"\n)\n\n",
    "supporting": [
      "Yashi analysis_files"
    ],
    "filters": [],
    "includes": {}
  }
}